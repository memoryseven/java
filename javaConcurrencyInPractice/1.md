##### 线程允许在同一个进程中同时存在多个程序控制流
##### 线程会共享进程范围内的资源
##### 线程提供了一种直观的分解模式来充分利用多处理器系统中的硬件并行性，而在同一个程序中的多个线程也可以同时调度到多个cpu上运行
##### 线程也被称为轻量级进程
##### 在大部分操作系统中，都是以线程为基本的调度单位。如果没有明确的协同机制，那么线程将彼此独立执行。由于同一进程中的所有县城都将共享进程中的内存地址空间，因此这些线程都能访问相同的变量并在同一堆上分配对象，因此需要一种比在进程间共享数据粒度更细的数据共享机制，来协同对数据的共享访问
##### 多线程程序可以在多个处理器上执行
##### 多线程程序可以通过提高处理器资源的利用率来提升系统吞吐率
##### 多线程有助于在单处理器系统的上获得更高的吞吐率
##### 如果是多线程程序，一个线程等待I/O操作，另一个线程可以继续执行，从而使整个程序能在I/O阻塞期间继续执行
##### 如果为每种类型的人物都分配一个专门的线程，那么可以形成一种串行执行的假象，并将程序的执行逻辑与调度机制的细节、交替执行的操作、异步I/O以及资源等待等问题分离开来。通过使用线程，可以将复杂并且异步的工作流进一步分解为一组简单并且同步的工作流，每个工作流在一个单独的线程中运行，并在特定的同步位置进行交互
##### 如果某个应用程序对套接字执行读操作，而此时还没有数据到来，那么这个读操作将一直处于阻塞状态，直到数据到达。在单线程应用程序中，这不仅意味着在处理请求的过程中将停顿，而且在这个线程被阻塞期间，所有的请求都将停顿。因此单线程服务器必须使用非阻塞I/O。如果每个请求都拥有自己的处理线程，那么在处理某个请求时的阻塞将不影响对其他请求的处理
##### 响应更灵敏的用户界面，GUI框架，AWT、Swing等，都采用一个事件分发线程Event Dispath Thread，EDT来替代主事件循环。当某个用户界面事件发生时，在事件线程中将调用应用程序的事件处理器
##### 如果在事件线程中执行的任务都是短暂的，那么界面响应的灵敏度就高
##### 线程风险，多个线程中的操作执行顺序是不可预测的。

    @NotThreadSafe
    public class UnsafeSequence{
        privete int value;
        /**返回一个唯一数值**/
        public int getNext(){
          return value++;
        }
    } 
    
##### UnsafeSequence()如果执行时机不对，那么两个线程将会得到相同的值。

    A value->9   ----   9+1->10  ----  value=10
    B  ----   value->9  ----   9+1->10   ----   value=10
    
##### @ThreadSafe 来标注某个类，开发人员就可以在多线程环境下放心的使用这个类，维护人员会发现这个类的保证线程安全。
##### 在UnsafeSequence类中说明的一种常见的并发安全问题，称为竟态条件Race Condition
##### 在多线程环境下，getValue是否返回唯一的值，要取决于运行时对线程中操作的交替执行方式
##### 由于多个线程要共享相同的内存地址空间，并且是并发运行，因此他们可能会访问或修改其他线程正在使用的变量。这也是一种很多大的便利，因为这种方式比其他线程间通信机制更容易实现数据共享。同样也带来了巨大的风险，线程由于无法预料的数据变化产生错误
##### 要使多线程程序的行为可以预测，必须对共享变量的操作进行协同，这样才不会在线程之间发生彼此干扰

    @ThreadSafe
    public class Sequence{
        @GuardedBy("this") private int value;
        
        public synchronized int getNext(){
          return value++;
        }
    }
    
##### 安全性是永远不会发生糟糕的事情，活跃性是某件正确的事情最终会发生
##### 线程带来的活跃性问题，如果线程A在等待线程B释放持有的资源，而B永远不释放该资源，死锁、饥饿、活锁等解决方案
##### 性能问题：服务时间过长、响应不灵敏、吞吐率低、资源消耗高等
##### 多线程程序中，当线程调度器临时挂起活跃线程并运行另一个线程时，就会频繁地出现上下文切换的操作ContextSwitch。这种操作将会带来极大的开销：保存和恢复上下文、丢失局部性、CPU时间将更多的花在线程调度而不是线程运行上。当线程数据共享时，必须使用同步机制，而这些机制往往会抑制某些编译器优化，使内存缓存区中的数据无效，以及增加共享内存总线的同步流量。

