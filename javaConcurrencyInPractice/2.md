###### 一个对象是否需要是线程安全的，取决于是否被多个线程访问
###### 要使得对象是线程安全的，需要采用同步机制来协同对对象可变状态的访问
###### 采用同步机制协同线程对变量的访问 synchronized，提供了独占的加锁方式
###### 线程访问无状态对象的行为并不会影响其他线程中操作的正确性，因此无状态对象是线程安全的
###### 在并发编程中，由于不恰当的执行时序！！而出现不正确的结果，竞态条件（Race Condition）
###### 最常见的竞态条件类型就是先检查后执行（Check-Then-Act），通过一个失效的结果决定下一步动作
###### 要避免竞态条件，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而保证其他线程只能在丢改完成之前或之后读取和修改状态，而不是在修改状态的过程中
###### 为了确保线程安全性，操作必须是原子的。复合操作：包含了一组必须以原子方式执行的操作以确保线程安全性
###### 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量
###### JAVA提供了一种内置的锁机制来支持原子性：同步代码块（synchronized Block）
###### 同步代码块分为两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字synchronsized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronsized方法以Class对象作为锁
###### 内置锁可重入
###### 如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁
###### 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的
###### 当获取与对象关联的锁时，并不能阻止其他线程访问该对象，某个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁
###### 一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得该对象上不会发生并发访问。在这种情况下，对象状态中的所有变量都有对象的内置锁保护起来。
