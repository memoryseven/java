###### 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些调整：重排序Reordering
###### 失效数据、最低安全性。
###### 内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。
###### 访问某个共享且可变的变量时要求所有的线程在同一个锁上同步，确保某个线程写入该变量的值对于其他线程来说是可见的。如果一个线程在未持有正确锁的情况下读取某个变量，那么读到的可能是一个失效值。
###### 加锁的含义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，所有执行读写操作的线程都必须在同一个锁上同步。
###### volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时，总会返回最新写入的值。
###### 在访问volatile变量时，不会执行枷锁操作，因此也就不会使执行的线程阻塞，因此volatile变量是一种比synchronized更轻量级的同步机制。
###### 在大多数处理器架构上，读取volatile变量的开销要比读取非volatile变量的开销略高一些。
###### 当线程A首先写入了一个volatile变量并且线程B随后读取该变量时，在写入volatile变量之前对A可见的所有变量的值，在B读取了volatile变量之后，对B也是可见的。从内存可见性的角度来看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。
###### 仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该被使用。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（如初始化或关闭）
```
  volatile boolean A:
      while(!A)
          action();
```
###### volatile变量的典型用法，检查某个状态标记以判断是否推出循环。可以用锁来确保A更新操作的可见性，但是代码将会变得复杂。
###### JVM -server
###### volatile变量通常用作某个操作完成、发生中断或者状态的标志
###### 加锁机制既可以确保可见性又可以确保原子性，volatile变量只能确保可见性，volatile的语义不足一确保操作的原子性，除非确保是单线程的操作。
###### 当且仅当满足一下条件时，才应该使用volatile变量：
###### 1.对变量的写入操作不依赖变量的当前值，或者你能确保之后单个线程更新变量的值
###### 2.该变量不会与其他状态变量一起纳入不变性条件中
###### 3.在访问变量时不需要加锁
###### 发布publish：使对象能够在当前作用域之外的代码中使用。如：将一个指向该变量的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中，
###### 当某个不应该发布的对象被发布时，这种情况被称为逸出escape
###### 发布内部状态会破坏封装性，并使得程序难以维持不变性条件。如果在对象构造完成之前就发布该对象，就会破坏线程安全性。
###### 发布对象最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象
```
  public static Set<Secret> knownSecrets;
  public void initialize(){
      knownSecrets = new HashSet<Secret>();
  }
```  
###### 当发布一个对象时，在该对象的非私有域中引用的所有对象都会被发布。
###### 封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得困难。
###### 不要在构造过程中使this引用逸出。
###### 当对象在其构造函数内创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。在对象未完全构造之前，新的线程就可以看见它。在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动。
###### 在构造函数中调用一个可改写的实例方法时，同样会导致this引用在构造过程中逸出。
###### 只有当构造函数返回时，this引用才应该从线程中逸出。构造函数可以将this引用保存到某个地方，只要其他线程不会在构造函数完成之前使用它。
###### 如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有构造函数和一个公共的工厂方法，从而避免不正确的构造过程。
  
```
public class SafeListener{
    private final EventListener listener;
        private SafeListener(){
            listener = new EventListener(){
            public void onEvent(Event e){
               doSomething(e);
            }
        }
    }
    public static SafeListener newInstance(EventSource source){
         SafeListener safe = new SafeListener();
         source.registerListener(safe.listener);
         return safe;
    }
  }
```
###### 



