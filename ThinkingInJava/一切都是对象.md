### 1.用引用操纵对象
##### 引用reference
##### String s;
##### 此时创建的只是引用，给s发消息，将会返回一个运行时错误
##### String s = "m";
### 2.必须由你创建所有对象
##### 2.1存储位置
###### 1.寄存器：最快的存储区，处理器内部，寄存器按需分配，不能直接控制
###### 2.堆栈：通常位于RAM随机访问寄存器中，通过堆栈可以从处理器那里获得直接支持。堆栈指针若向下移动，则分配新的内存；若向上移动则释放那些内存。创建程序时，java系统必须知道储存在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性，某些java数据存储于堆栈中，比如对象的引用，但是java对象不存储在其中
###### 3.堆：一种通用内存池（也位于RAM区），用于存放所有java对象，堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里的存活时间。因此在堆里分配存储有很大的灵活性。当需要一个对象时，只需要new写一行简单代码，当执行这些代码时，会自动在堆里进行存储分配。这种灵活性的代价是：用堆进行存储分配和清理可能比用堆栈进行存储分配需要更多的时间
###### 4.常量存储：直接放在程序代码内部/ROM只读寄存器
###### 5.非RAM存储：如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。
###### 例如流对象和持久化对象。在流对象中，对象转化成字节流，通常被发送给另一台机器。持久化对象，被存放于磁盘上，把对象转化成可以存放在其他媒介上的事物，在需要时，恢复成常规、基于RAM的对象，JDBC、Hibernate
##### 2.2特例：基本类型
###### 不需要new来创建，而是创建一个非引用的变量。这个变量直接存储值，并置于堆栈中
######
| 基本类型      |    大小 | 最小值  | 最大值  | 包装器类型  |
| :--------: | :--------:| :--: | :--: | :--: |
| boolean  | - |  -   | -  | Boolean  |
| char     |   64-bit |  Unicode 0  | Unicode 2^16-1  | Character  |
| byte     |   8 bits | -128  | +127  | Byte  |
| short    |  16 bits | -2^15  | +2^15-1  | Short  |
| int    |  32 bits | -2^31  | +2^31-1  | Integer  |
| long   |  64 bits | -2^63  | +2^63-1  | Long  |
| float   |  32 bits | IEEE754  | IEEE754  | Float  |
| double  |  64 bits | IEEE754  | IEEE754  | Double  |
| void  |  - | -  | -  | Void  |

###### 所有数值类型都有正负号
###### 基本数据类型具有的包装类，使得可以在堆中创建一个非基本对象，用来表示对应的基本类型

    char c = 'x';
    Character ch = new Character(c);
    //或者
    Character ch = new Character('x');
    //Java SE5自动包装功能，可以自动将基本数据类型转换为包装器类型：
    Character ch = 'x';
    //反向
    char c = ch;
    
###### 高精度数字计算类：BigInteger   BigDecimal
###### BigInteger：任意精度的整数，可以准确表示任何大小的整数值，而不会丢失任何信息
###### BigDecimal：任意精度的定点数，精确货币计算
##### 2.3JAVA中的数组
###### JAVA确保数组会被初始化，而且不能在他的范围之外访问。
###### 当创建一个数组对象时，实际上是创建了一个引用数组，并且每一个引用都会自动被初始化为一个特定值，该值拥有自己的关键字null。一旦看到null，java就知道这个引用没有指向某个对象。在使用任何引用前，必须为其指定一个对象，如果试图使用一个还是null的引用，在运行时将会报错。
###### 基本类型数组全部为零
### 3.永远不需要销毁对象
##### 3.1作用域scope，作用域决定了气馁定义的变量名的可见性和生命周期
    
    {
        int x = 12;
        // only x available
        {
            int q = 96;
            // both x & q available
        }
        // only x available
        // q is put of scope
    }
##### 3.2对象的作用域
###### 对象不具备和基本类型一样的生命周期，当用new创建一个java对象时，它可以存活于作用域之外。

    {
        String s = new String("a string");
    }// end of scope
    
###### 引用s在作用域终点就消失了，然后s指向的String对象仍继续占据内存空间。上述代码无法在这个作用域之后访问这个对象，因为对它唯一的引用已经超出了作用域的范围？？？Mark
###### 由new创建的对象，只要你需要，就会一直保留下去
###### JAVA垃圾回收机制，监控用new创建的所有对象，并辨别那些不会在被倍引用的对象，释放这些对象的内存空间
### 4.创建新的数据类型：类class
##### 4.1字段和方法  【字段（成员）、方法（成员函数）】
###### 字段可以是任何类型的对象，可以通过其引用与其进行通信；也可以是基本数据类型。如果字段是对某个对象的引用，那么必须初始化该引用，以便使其与一个实际对象相关联
###### 每个对象都有用来存储其字段的空间，普通字段不能在对象间共享
######
| 基本类型      |    默认值 |
| :--------: | :--------:|
| boolean  | false | 
| char     |   '\u0000'(null) |
| byte     |   (byte)0 |
| short    |  (short)0 |
| int    |  0 |
| long   |  0L |
| float   |  0.0f |
| double  |  0.0d |
###### 如果成员是基本数据类型，即使没有初始化，java也会确保它的默认值；
    int x;//但是在某个方法里 返回一个编译时错误，必须初始化
### 5.方法、参数和返回值
###### JAVA中的方法只能作为类的一部分来创建，方法只有通过对象才能被调用（静态方法可以直接通过类调用）
###### JAVA中任何传递对象的场合都是对象的引
### 6.
#### static 关键字
##### 通常来说，当创建类时，就是在描述那个类的对象的外观和行为。除非用new创建对象，否则并未获得任何对象。执行new来创建对象时，数据存储空间才被分配，其方法才供外界调用
##### 有两种情况用上述方法无法解决。1是只想为特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至恩本就不创建任何对象。2是希望某个方法不与包含它的类和任何对象关联在一起，也就是说，即使没创建new对象，也能够调用这个方法。
##### 通过static关键字可以满足上述要求。当声明一个事物是static时，就意味着这个域或方法不会与包含它的类的任何对象关联在一起。即使从未创建某个类的任何对象，也可以调用其static方法或访问其static域。非static域或方法必须知道他们一起运作的特定对象：对于static方法，不能简单地通过调用其他非static域或方法而没有指定某个命名对象的方式，来直接访问非static域或方法，必须与某一特定对象关联。
##### 使用类名是引用static变量的首选方式，这不仅是因为它强调了变量的static结构，而且在某些情况下，为编译器进行优化提供了更好的机会，类似的逻辑也适用与静态方法。
##### 当static作用于某个字段时，肯定会改变数据创建的方式，因为一个static字段对每个类来说都只有一份存储空间，而非static字段则是对每个对象有一个存储空间，但是如果static作用于某个方法，差别却没这么大。static方法的一个重要用法就是在不创建任何对象的前提下可以直接调用它，如main()程序的入口点
    public static void main(String[] args){}
##### public关键字表示一个可以由外部调用的方法，main()方法的参数是一个String对象的数组，虽然在程序中并未使用args，用来存储java编译器需要的命令行参数
### 7.编译与运行
##### JDK   java javac
### 8.注释和嵌入文档
##### 标签
###### 1.@see 引用其他类
###### @see标签允许用户引用其他类的文档，javadoc会在其生成的HTML文件中，通过@see标签链接到其他文档。
    @see classname
    @see fully-qualified-classname
    @see fully-qualified-classname#method-nae
##### 2.{@link package.class#member label}
###### 该标签与@see相似，只是用于行内
##### 3.{@docRoot}
###### 该标签产生到文档根目录的相对路径，用于文档树页面显式超链接
##### 4.{@inheritDoc}
###### 该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释中
##### 5.@version
    @version version-information
###### 其中version-information可以是任何你认为适合包含在版本说明中的重要信息。如果javadoc命令行使用了 -version标记，那么就从生成的HTML文档中特别提取出版本信息
##### 6.@author
###### 如果javadoc命令行使用了 -author标记，那么就从生成的HTML文档中特别提取出作者信息
##### 7.@since
###### 该标签允许你指定程序代码最早使用的版本
##### 8.@param
    @param parameter-name description
###### parameter-name是房中的参数列表中的标识符，description是可延续数行的文本，终止于新的文档标签出现之前。
##### 9.@return
###### 该标签用于方法文档，描述返回值的含义
##### 10.@throws
    @throws fully-qualified-class-name description
###### 异常类的名字，该异常类在别处定义
##### 11.@deprecated
###### 用于指出一些旧特性已由改进的心特性所取代，不建议使用，在不久的将类可能会被删除
