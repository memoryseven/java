### 1.抽象过程
###### 解决问题的复杂性取决于抽象的类型和质量
###### 将问题空间中的元素及其解空间中的表示称为对象
###### 通过添加新类型的对象使自身适用于某个特定问题（无法类比为问题空间元素的对象）
######  万物皆为对象
######  程序是对象的集合，它们通过发消息来告知彼此所要做的。消息作为对某个特定对象方法的调用请求。
######  每个对象都有自己的由其他对象所构成的存储。通过创建包含现有对象的包的方式来创建新类型的对象。在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后。
###### 每个对象都用有其类型。每个对象都是某个类class的实例instance。每个class最重要区别于其他class的特性就是可以给它发怎样的消息。
###### 某一特定类型的所有对象都可以接收同样的消息。
###### 对象具有形态、行为和标识
###### 每一个对象都可以拥有内部数据（对象的状态）和方法（对象产生的行为），每个对象都可以唯一的与其他对象区分（在内存中有唯一的地址）
### 2.每个对象都有一个接口
###### 所有对象都是唯一的，但也是具有相同的特性和行为的对象所归属的类的一部分
###### 创建抽象数据类型（类class）是面向对象设计的基本概念。抽象数据类型的运行方式和内置（build-in）类型几乎完全一致：创建某类型的变量（对象或实例），然后操作这些变量（发消息）。每个类的成员或元素都具有某种共性、都有自身的状态。每一个对象都属于定义了特性和行为的某个特定的类。
###### 由于类描述了具有相同特性（元素、成员）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。程序通过定义类来适应问题。
###### 问题空间的元素和解空间的对象之间创建对应关系
###### 接口确定了某一特定对象所能发出的请求，程序中必须有满足这些请求的代码，这些代码和隐藏数据一起构成了实现。在类型中，每一个可能的请求都有一个方法与之关联，当向对象发送请求时，与之关联的方法就会被调用。
### 3.每个对象都提供服务
###### 程序本身向用户提供服务，它将通过调用其他对象提供的服务来实现这个目的。目标就是创建能够提供理想的服务来解决问题的一系列对象。
###### 将对象看作是服务提供者有助于提高对象的内聚性，每个对象都有一个它所能提供服务的内聚的集合。
### 4.被隐藏的具体实现
###### 访问控制：让客户端程序员无法触及他们不应该触及的部分，这些部分对数据类型内部操作来说是必须的，但不是解决特定问题的接口的一部分；允许库设计者可以改变内部的工作方式而不用担心会影响到客户端程序员。
###### 接口和实现清晰地分离并得以保护
###### public private  protected
###### public 紧随气候的元素对任何人都是可用的
###### private 除类型创建者和类型的内部方法之外的任何人都不能访问元素
###### protected 与private相当，差别仅在于继承的类可以方位protected成员，但是不能访问private成员
###### 默认访问权限，没有任何法官问制定词，成为包访问权限，类可以访问在同一个包中的其他类成员，但在包外，就如同private一样
### 5.复用具体实现
###### 一旦类被创建并测试完，它就该代表一个有用的代码单元。一旦有了这样的设计，它就可以提供复用。
###### 最简单地复用某个类的方式就是直接使用该类的一个对象，也可以将类的一个对象置于某个新的类中。新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。使用现有类合成新类的方式称为组合composition，如果组合是动态发生的，也被成为聚合aggregation。组合经常视为拥有has-a的关系。
###### 在创建新类时，优先考虑组合，然后再考虑继承。
### 6.继承
###### 继承解决的问题：在创建了一个类之后，即使另一个新类即使与其具有想类的功能，还是要重新创建一个新类。如果能以现有类为基础，复制它，然后通过添加和修改这个副本创建新的类。
###### 当基类发生变动时，导出类也会反映出这些变动。
###### 类型不仅仅描述了作用于一个对象集合上的约束条件，同时还有与其他类型之间的关系。两个类型可以有相同的特性和行为，但是其中一种类型可能包含更多的特性，并且可以处理更多的消息。继承使用基类和导出类的概念表示了这种类型的相似性。
###### 一个基类包含其所有导出类所共享的特性和行为，可以创建一个基类来表示系统中某些对象的核心概念，从基类型中导出其他类型，来表示此核心可以被实现的各种不同方式。
###### 当继承现有类型时，就创建了新的类型，这个新的类型不仅包含了现有类型的所有成员（尽管private成员被隐藏并且不可访问），重要的是复制了基类的接口。也就是说，所有可以发送给基类的消息也可以发送给导出类对象。
###### 由于通过发送给类的消息的类型可知类的类型，所以就代表基类和导出类具有相同的类型。通过继承产生的类型具有等价性。
###### 由于基类和导出类具有相同的基础接口，所以伴随此接口的必定有某些具体实现。
###### 有两种方法可以使基类和导出类产生差异。
####### 1.直接在导出类中添加新方法。这些新方法并不是接口的一部分，这也意味着基类不能直接满足你的所有要求。这时，应该考虑基类是否也需要这些额外方法的可能性。
####### 2.覆盖overriding，改变现有基类的方法的行为。在导出类中创建该方法的新的定义。
### 6.是一个与像是一个关系
###### 如果继承只覆盖基类的方法，而不添加基类中没有的方法，就意味着基类和导出类具有完全相同的类型，具有完全相同的接口。结果可以用一个导出类对象完全代替基类对象。这种继承方式视为替代原则。将这种基类和导出类的关系称为is-a是一个关系。一个圆形就是一个几何形状。判断是否是继承，就是要确定是否可以用is-a来描述类之间的关系，并使之具有实际意义。
###### 有时必须在导出类中添加新的接口元素，扩展接口。这个新的类型仍然可以替代基类，但是这种替代并不完美，因为基类无法访问新添加的方法。这是一种is-liake-a像是一个关系。新类型具有旧类型的接口，但是还包含其他方法。
### 7.伴随多态的可互换对象
##### 在处理类型的层次结构时，经常把一个对象不当作它所属的特定类型来对待，而是将其当作其基类的对象来对待。
###### 例：在几何形例子中，方法操作都是泛化generic的形状，而不关心正方形、三角形等，所有的几何形状都可以被绘制、擦除和移动，这些方法都是直接对一个几何形的对象发消息，不担心对象如何处理消息。
##### 这样的代码不会受到添加新类型的影响，添加新类型是扩展程序和醋里新情况的最常用方式。
###### 例：从几何形中导出一个新的子类型五角形，而不需要修改处理泛化几何形状的方法。通过导出新的子类型而轻松扩展设计的能力是对改动进行封装的基本方式之一。
##### 如果某个方法要让泛化的几何形状绘制自己、让泛化的交通工具形式，那么编译器在编译时不知道应该执行那一部分。当发送这样的消息时，绘制方法可以被等同的应用与圆形、正方形等，而对象会根据自己的具体类型来执行恰当的代码。
##### 面向对象编程采用后期绑定，当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并调用参数和返回值执行类型检查（无法提供此类保证的语言被称为弱类型），但是并不知道将被执行的确切代码。

      void doSomething(Shape shape){
         shape.erase();
         //...
         shape.draw();
      }
      Cricle circle=new Circle();
      Triangle triangle=new Triangle();
      Line line=new Line();
      doSomething(circle);
      doSomething(triangle);
      doSomething(line);




